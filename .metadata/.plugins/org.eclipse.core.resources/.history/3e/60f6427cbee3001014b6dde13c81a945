package com.cvbuilder.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.*;
import org.springframework.web.util.UriComponentsBuilder;

import java.time.Duration;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

@Service
public class TranslationService {

    private static final Logger log = LoggerFactory.getLogger(TranslationService.class);

    @Value("${groq.api.keys:}")
    private String groqApiKeysString;
    @Value("${groq.api.url:https://api.groq.com/openai/v1/chat/completions}")
    private String groqUrl;
    @Value("${groq.model:llama-3.3-70b-versatile}")
    private String groqModel;

    @Value("${gemini.api.keys}")
    private String geminiApiKeysString;
    @Value("${gemini.model}")
    private String modelName;
    @Value("${gemini.api.url:https://generativelanguage.googleapis.com/v1beta}")
    private String baseApiUrl;

    @Value("${deepseek.api.keys:}")
    private String deepSeekApiKeysString;
    @Value("${deepseek.api.url:https://api.deepseek.com/chat/completions}")
    private String deepSeekUrl;
    @Value("${deepseek.model:deepseek-chat}")
    private String deepSeekModel;

    private List<String> groqKeys;
    private List<String> geminiKeys;
    private List<String> deepSeekKeys;

    private final AtomicInteger currentGeminiIndex = new AtomicInteger(0);
    private final AtomicInteger currentGroqIndex = new AtomicInteger(0);
    private final AtomicInteger currentDeepSeekIndex = new AtomicInteger(0);

    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper = new ObjectMapper();

    public TranslationService() {
        this.restTemplate = new RestTemplateBuilder()
                .setConnectTimeout(Duration.ofSeconds(10))
                .setReadTimeout(Duration.ofSeconds(60))
                .build();
    }

    @PostConstruct
    public void init() {
        this.groqKeys = parseKeys(groqApiKeysString);
        this.geminiKeys = parseKeys(geminiApiKeysString);
        this.deepSeekKeys = parseKeys(deepSeekApiKeysString);
    }

    private List<String> parseKeys(String raw) {
        if (raw == null || raw.isBlank()) return List.of();
        return Arrays.stream(raw.split(","))
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .toList();
    }

    private String getNextKey(List<String> keys, AtomicInteger index) {
        if (keys == null || keys.isEmpty()) throw new RuntimeException("API Key Listesi Boş!");
        int idx = Math.abs(index.getAndIncrement() % keys.size());
        return keys.get(idx);
    }

    // GÖREV PAYLAŞIMI YAPAN ANA METOT
    public String generateContentWithProvider(String prompt, String provider) {
        if ("GEMINI".equalsIgnoreCase(provider)) {
            try {
                return sendRequestToGemini(prompt);
            } catch (Exception e) {
                log.warn("Gemini başarısız, Groq deneniyor: {}", e.getMessage());
                return sendRequestToGroq(prompt);
            }
        } else {
            try {
                return sendRequestToGroq(prompt);
            } catch (Exception e) {
                log.warn("Groq başarısız, Gemini deneniyor: {}", e.getMessage());
                return sendRequestToGemini(prompt);
            }
        }
    }

    public String generateContent(String prompt) {
        return generateContentWithProvider(prompt, "GROQ");
    }

    private String sendRequestToGemini(String prompt) {
        String safeModelName = modelName.startsWith("models/") ? modelName : "models/" + modelName;
        String key = getNextKey(geminiKeys, currentGeminiIndex);
        String apiUrl = UriComponentsBuilder.fromHttpUrl(baseApiUrl)
                .pathSegment(safeModelName + ":generateContent")
                .queryParam("key", key).toUriString();

        Map<String, Object> requestBody = Map.of("contents", List.of(Map.of("parts", List.of(Map.of("text", prompt)))));
        ResponseEntity<String> response = restTemplate.postForEntity(apiUrl, requestBody, String.class);
        return parseResponseSafe(response.getBody());
    }

    private String sendRequestToGroq(String prompt) {
        String key = getNextKey(groqKeys, currentGroqIndex);
        Map<String, Object> requestBody = Map.of("model", groqModel, "messages", List.of(Map.of("role", "user", "content", prompt)));
        
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "Bearer " + key);
        headers.setContentType(MediaType.APPLICATION_JSON);

        ResponseEntity<String> response = restTemplate.postForEntity(groqUrl, new HttpEntity<>(requestBody, headers), String.class);
        return parseResponseSafe(response.getBody());
    }

    private String sendRequestToDeepSeek(String prompt) {
        String key = getNextKey(deepSeekKeys, currentDeepSeekIndex);
        Map<String, Object> requestBody = Map.of("model", deepSeekModel, "messages", List.of(Map.of("role", "user", "content", prompt)));
        
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "Bearer " + key);
        headers.setContentType(MediaType.APPLICATION_JSON);

        ResponseEntity<String> response = restTemplate.postForEntity(deepSeekUrl, new HttpEntity<>(requestBody, headers), String.class);
        return parseResponseSafe(response.getBody());
    }

    private String parseResponseSafe(String responseBody) {
        try {
            JsonNode root = objectMapper.readTree(responseBody);
            if (root.has("choices")) return root.path("choices").get(0).path("message").path("content").asText();
            if (root.has("candidates")) return root.path("candidates").get(0).path("content").path("parts").get(0).path("text").asText();
            return responseBody;
        } catch (Exception e) { return responseBody; }
    }
}