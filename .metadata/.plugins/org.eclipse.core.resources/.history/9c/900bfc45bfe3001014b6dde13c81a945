package com.cvbuilder.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.*;
import org.springframework.web.util.UriComponentsBuilder;

import java.time.Duration;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * TranslationService (Ultimate Version)
 * Zincirleme AI Sistemi:
 * 1. Groq (Multi-Key) -> PRIMARY
 * 2. Gemini (Multi-Key) -> SECONDARY
 * 3. DeepSeek (Multi-Key) -> TERTIARY
 */
@Service
public class TranslationService {

    // ==========================================
    // 1. GROQ CONFIG
    // ==========================================
    @Value("${groq.api.keys:}")
    private String groqApiKeysString;
    @Value("${groq.api.url:https://api.groq.com/openai/v1/chat/completions}")
    private String groqUrl;
    @Value("${groq.model:llama-3.3-70b-versatile}")
    private String groqModel;

    // ==========================================
    // 2. GEMINI CONFIG
    // ==========================================
    @Value("${gemini.api.keys}")
    private String geminiApiKeysString;
    @Value("${gemini.model}")
    private String modelName;
    @Value("${gemini.api.url:https://generativelanguage.googleapis.com/v1beta}")
    private String baseApiUrl;

    // ==========================================
    // 3. DEEPSEEK CONFIG
    // ==========================================
    @Value("${deepseek.api.keys:}")
    private String deepSeekApiKeysString;
    @Value("${deepseek.api.url:https://api.deepseek.com/chat/completions}")
    private String deepSeekUrl;
    @Value("${deepseek.model:deepseek-chat}")
    private String deepSeekModel;

    // Anahtar Listeleri ve İndeksler
    private List<String> groqKeys;
    private List<String> geminiKeys;
    private List<String> deepSeekKeys;

    private final AtomicInteger currentGeminiIndex = new AtomicInteger(0);
    private final AtomicInteger currentGroqIndex = new AtomicInteger(0);
    private final AtomicInteger currentDeepSeekIndex = new AtomicInteger(0);

    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper = new ObjectMapper();

    public TranslationService() {
        this.restTemplate = new RestTemplateBuilder()
                .setConnectTimeout(Duration.ofSeconds(10))
                .setReadTimeout(Duration.ofSeconds(60)) 
                .build();
    }

    @PostConstruct
    public void init() {
        // 1. Groq Init
        this.groqKeys = parseKeys(groqApiKeysString);
        if (this.groqKeys.isEmpty()) System.err.println("UYARI: Groq anahtarları yok!");

        // 2. Gemini Init
        this.geminiKeys = parseKeys(geminiApiKeysString);
        if (this.geminiKeys.isEmpty()) System.err.println("UYARI: Gemini anahtarları yok!");

        // 3. DeepSeek Init
        this.deepSeekKeys = parseKeys(deepSeekApiKeysString);
        if (this.deepSeekKeys.isEmpty()) System.err.println("UYARI: DeepSeek anahtarları yok!");
    }

    private List<String> parseKeys(String raw) {
        List<String> list = new ArrayList<>();
        if (raw != null && !raw.isBlank()) {
            for (String k : raw.split(",")) {
                String t = k.trim();
                if (!t.isEmpty()) list.add(t);
            }
        }
        return list;
    }

    private String getNextKey(List<String> keys, AtomicInteger index) {
        if (keys == null || keys.isEmpty()) throw new RuntimeException("API Key Listesi Boş!");
        int idx = Math.abs(index.getAndIncrement() % keys.size());
        return keys.get(idx);
    }

    // =========================================================
    // PUBLIC METHODS (ZİNCİRLEME MANTIK VE MODEL AYRIMI)
    // =========================================================

    /**
     * ÖNEMLİ: AiClient'ın model seçebilmesini sağlayan metot.
     * provider = "GEMINI" ise önce Gemini'yi, hata verirse Groq'u dener.
     * provider = "GROQ" (veya başka bir şey) ise önce Groq'u, hata verirse Gemini'yi dener.
     */
    public String generateContentWithProvider(String prompt, String provider) {
        if ("GEMINI".equalsIgnoreCase(provider)) {
            try {
                return sendRequestToGemini(prompt);
            } catch (Exception e1) {
                System.err.println("Öncelikli Gemini başarısız, Groq deneniyor...");
                try {
                    return sendRequestToGroq(prompt);
                } catch (Exception e2) {
                    return sendRequestToDeepSeek(prompt);
                }
            }
        } else {
            // Varsayılan: Önce Groq (Llama)
            try {
                return sendRequestToGroq(prompt);
            } catch (Exception e1) {
                System.err.println("Öncelikli Groq başarısız, Gemini deneniyor...");
                try {
                    return sendRequestToGemini(prompt);
                } catch (Exception e2) {
                    return sendRequestToDeepSeek(prompt);
                }
            }
        }
    }

    public String generateContent(String prompt) {
        // Mevcut metot, ana yapıyı korumak için Groq öncelikli çalışmaya devam eder.
        return generateContentWithProvider(prompt, "GROQ");
    }

    public Map<String, Object> translateCV(Object userCvData, String targetLang) {
        String languageName = targetLang.equalsIgnoreCase("en") ? "English" : targetLang;
        String jsonInput;
        try {
            jsonInput = objectMapper.writeValueAsString(userCvData);
        } catch (Exception e) {
            throw new RuntimeException("JSON Hatası: " + e.getMessage());
        }

        String prompt = String.format(
                "You are an expert CV translator. Translate the JSON values into %s. " +
                        "STRICT RULES:\n" +
                        "1) Do not change JSON structure. Only translate string values.\n" +
                        "2) Keep technical terms (e.g., Java, Spring, AWS) and company names unchanged.\n" +
                        "3) Do not modify id, email, phone, linkedinUrl or date fields.\n" +
                        "4) Return ONLY valid JSON (no markdown, no backticks).\n\nINPUT_JSON:\n%s",
                languageName,
                jsonInput
        );

        // Tercüme için Llama (Groq) daha iyidir, o yüzden default akış kullanılır.
        String aiText = generateContent(prompt);

        String cleaned = cleanPossibleCodeFences(aiText);
        try {
            return objectMapper.readValue(cleaned, Map.class);
        } catch (Exception e) {
            throw new RuntimeException("AI yanıtı JSON formatında değil: " + cleaned.substring(0, Math.min(100, cleaned.length())) + "...");
        }
    }

    // =========================================================
    // CORE: REQUEST METHODS
    // =========================================================

    private String sendRequestToGemini(String prompt) {
        if (geminiKeys == null || geminiKeys.isEmpty()) throw new RuntimeException("Gemini keys yok");
        String safeModelName = modelName.startsWith("models/") ? modelName : "models/" + modelName;
        int maxAttempts = Math.max(1, geminiKeys.size());

        Map<String, Object> part = Map.of("text", prompt);
        Map<String, Object> content = Map.of("parts", List.of(part));
        Map<String, Object> requestBody = Map.of("contents", List.of(content));

        for (int attempt = 0; attempt < maxAttempts; attempt++) {
            String key = getNextKey(geminiKeys, currentGeminiIndex);
            String apiUrl = UriComponentsBuilder.fromHttpUrl(baseApiUrl)
                    .pathSegment(safeModelName + ":generateContent")
                    .queryParam("key", key)
                    .build()
                    .toUriString();

            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            HttpEntity<Map<String, Object>> entity = new HttpEntity<>(requestBody, headers);

            try {
                ResponseEntity<String> response = restTemplate.postForEntity(apiUrl, entity, String.class);
                if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                    return parseResponseSafe(response.getBody());
                }
            } catch (Exception e) {
                System.err.println("Gemini denemesi başarısız (" + maskKey(key) + "): " + e.getMessage());
            }
        }
        throw new RuntimeException("Tüm Gemini anahtarları denendi ve başarısız oldu.");
    }

    private String sendRequestToGroq(String prompt) {
        if (groqKeys == null || groqKeys.isEmpty()) throw new RuntimeException("Groq keys yok");
        int maxAttempts = Math.max(1, groqKeys.size());

        Map<String, Object> message = Map.of("role", "user", "content", prompt);
        Map<String, Object> requestBody = Map.of(
                "model", groqModel,
                "messages", List.of(message),
                "temperature", 0.7
        );

        for (int attempt = 0; attempt < maxAttempts; attempt++) {
            String key = getNextKey(groqKeys, currentGroqIndex);
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            headers.set("Authorization", "Bearer " + key);
            HttpEntity<Map<String, Object>> entity = new HttpEntity<>(requestBody, headers);

            try {
                ResponseEntity<String> response = restTemplate.postForEntity(groqUrl, entity, String.class);
                if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                    return parseResponseSafe(response.getBody());
                }
            } catch (Exception e) {
                System.err.println("Groq denemesi başarısız (" + maskKey(key) + "): " + e.getMessage());
            }
        }
        throw new RuntimeException("Tüm Groq anahtarları denendi ve başarısız oldu.");
    }

    private String sendRequestToDeepSeek(String prompt) {
        if (deepSeekKeys == null || deepSeekKeys.isEmpty()) throw new RuntimeException("DeepSeek keys yok");
        int maxAttempts = Math.max(1, deepSeekKeys.size());

        Map<String, Object> message = Map.of("role", "user", "content", prompt);
        Map<String, Object> requestBody = Map.of(
                "model", deepSeekModel,
                "messages", List.of(message),
                "temperature", 0.7
        );

        for (int attempt = 0; attempt < maxAttempts; attempt++) {
            String key = getNextKey(deepSeekKeys, currentDeepSeekIndex);
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            headers.set("Authorization", "Bearer " + key);
            HttpEntity<Map<String, Object>> entity = new HttpEntity<>(requestBody, headers);

            try {
                ResponseEntity<String> response = restTemplate.postForEntity(deepSeekUrl, entity, String.class);
                if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                    return parseResponseSafe(response.getBody());
                }
            } catch (Exception e) {
                System.err.println("DeepSeek denemesi başarısız: " + e.getMessage());
            }
        }
        throw new RuntimeException("Tüm DeepSeek anahtarları denendi ve başarısız oldu.");
    }

    // =========================================================
    // HELPERS
    // =========================================================

    private String parseResponseSafe(String responseBody) {
        try {
            JsonNode root = objectMapper.readTree(responseBody);
            if (root.has("choices")) {
                return root.path("choices").get(0).path("message").path("content").asText();
            }
            if (root.has("candidates")) {
                return root.path("candidates").get(0).path("content").path("parts").get(0).path("text").asText();
            }
            return responseBody;
        } catch (Exception e) {
            return responseBody;
        }
    }

    private String cleanPossibleCodeFences(String text) {
        if (text == null) return "";
        String cleaned = text.replaceAll("(?s)```.*?```", "").trim();
        cleaned = cleaned.replaceAll("^`+|`+$", "").trim();
        return cleaned;
    }

    private String maskKey(String key) {
        if (key == null || key.length() < 8) return "****";
        return key.substring(0, 4) + "..." + key.substring(key.length() - 4);
    }
}